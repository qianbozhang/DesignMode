#工厂模式属于创建型模式，大致可以分为三类，简单工厂模式、工厂方法模式、抽象工厂模式。

1.简单工厂模式:
描述：主要特点是需要在工厂类中做判断，从而创造相应的产品。当增加新的产品时，就需要修改工厂类。
缺点: 就是要增加新的核类型时，就需要修改工厂类。这就违反了开放封闭原则：软件实体（类、模块、函数）可以扩展，但是不可修改。

示例：有一家生产处理器核的厂家，它只有一个工厂，能够生产两种型号的处理器核。客户需要什么样的处理器核，一定要显示地告诉生产工厂。
A.需要的产品 enum {CORE_A,CORE_B}
B.工厂类SignalCore具备的功能，假设为show()
C.分别实现CORE_A/CORE_B 客制化的功能show()
D.定义芯片工厂类CoreFactory，可以生产两种型号的处理器核，在内部判断 

代码：Simple_Factory.cpp



2.工厂方法模式
描述：是指定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类。
缺点：每增加一种产品，就需要增加一个对象的工厂。

示例：还是以刚才的例子解释。这家生产处理器核的产家赚了不少钱，于是决定再开设一个工厂专门用来生产B型号的单核，而原来的工厂专门用来生产A型号的单核。这时，客户要做的是找好工厂，比如要A型号的核，就找A工厂要；否则找B工厂要，不再需要告诉工厂具体要什么型号的处理器核了。
//A.需要的产品 enum {CORE_A,CORE_B}
B.工厂类SignalCore具备的功能，假设为show()
C.分别实现CORE_A/CORE_B 客制化的功能show()
D.定义芯片工厂抽象类CoreFactory，可以生产两种型号的处理器核 
F.分别实现Factory A/B

代码：Factory_Method.cpp


3.抽象工厂模式
描述：为提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。
示例：还是举这个例子，这家公司的技术不断进步，不仅可以生产单核处理器，也能生产多核处理器。现在简单工厂模式和工厂方法模式都鞭长莫及。抽象工厂模式登场了。它的定义为提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。具体这样应用，这家公司还是开设两个工厂，一个专门用来生产A型号的单核多核处理器，而另一个工厂专门用来生产B型号的单核多核处理器。
//A.需要的产品 enum {CORE_A,CORE_B}
B.工厂类SignalCore/MultiCore具备的功能，假设为show()
C.分别实现CORE_A/CORE_B 客制化的功能show()
D.定义芯片工厂抽象类CoreFactory，可以生产两种型号的处理器核
F.分别实现SignalFactory A/B 和MultiFactory A/B

